浏览器
历史
- 真正显示图片的浏览器（迭代历史）
1. mosaic
2. Netscape navigator 网景
3. Mozilla Firefox

浏览器组成
- 两大部分
1. shell（贝壳，显示出来/用户能操作的部分）
2. 内核（看不到的部分）——>渲染进程？？里面的线程？？？
  1. 渲染引擎（从上到下，一层一层绘制，16.7ms更新一次）：语法规则和渲染
  2. js引擎
  3. 其他模块（异步）

- 其中js引擎的历史
  - ie6浏览器的js引擎：trident，把js引擎首次从内核独立出来
  - chrome浏览器的js引擎：webkit/blink（V8），把js代码直接转为机械码执行，速度快（原本应该是：js—>c++—>汇编码—>机械码—>执行）
  - firefox浏览器的js引擎：gecko，路径优化
  - Opera浏览器的js引擎：presto
  - safari浏览器的js引擎：webkit


语言
特征
1. 解释性语言
- 顶层语言翻译成机械码有不同的翻译的方法，分为：
  - 编译性：通篇翻译一下，然后一起执行。并非看一行执行一行
  - 解释性：翻译一行执行一行，然后在翻译第二行
- 优缺点：
  - 编译性：（c、c++）
    - 优点：快（系统类的底层）
    - 缺点：移植性不好（必须生成一个文件，因此不跨平台）

  - 解释性：（js、php）
    - 优点：跨平台（一行一行执行，不需要生成一个文件，不同平台都认识01）
    - 缺点：稍微慢

- 另外的：jvm（java虚拟机）
.java文件——（javac的指令）——（编译）——>.class文件——>jvm（解释执行）


2. 单线程（js引擎）
（一个人一个时间只能干一件事，不能左手画圆右手画方）

- 分类
  - 同步：一件事做完再做下一件事。（但很快，且这一件事不一定是一件完整的事，看下面的#执行队列）
  - 异步：同时执行

- 执行队列
轮转时间片：类似吃饭
[图片]
把任务切成一个个片段，随机性地排队，然后输入到js引擎里面


3. 语法规则
原生的：ECMAscript
DOM
BOM


基础使用
js的位置
- script标签
  - script标签的type还可以写成“text/tpl”，代码块无效，不执行，但里面可以存一下代码，后面可以取出来使用


规则
- 加分号：函数、for循环、if判断不用加；
- 错误：
  - 低级错误（语法解析错误）
    - 不对的符号
    - 在一行行解析之前，先通篇扫一遍看有没有低级错误，有则通篇都不会执行
  - 标准错误（逻辑错误）
    - 打印没有定义的变量
    - 执行到这行报错，然后后面的不再执行，上面的执行是正常的

（一个代码块的错误不会影响到另一个代码块的错误）



变量
- 变量声明与赋值：
  - 变量声明：
let a;

let a, b, c, d;
  - 变量赋值:
a = 100;
  - （先）变量声明，（后）赋值：
let a = 10,
    b = 20,
    c = 30;
  - （先）变量声明，（再）运算（从左到右），（最后）赋值（从右向左）
let a = b++ + 20;

- 变量命名：
_或$或字母为开头
_或$或字母或数字为内容

数据
- 数据类型
  - 原始值
    - Number
    - String
    - Boolean
    - Undefined
    - Null
  - 存放位置：栈（先进后出）
    - 栈内存之间的赋值是拷贝（比如用一个现有的值赋给一个新值）
    - 原始值是不可改变的！！！这句话如何理解？（数据进去房间之后就不能修改）
let num = 100;
num2 = num;
num = 200

// 最后的地方把num的值改变了，实际上已经存在房间里面的值是不可以被改变的
// 底层的实现不是去num的房间直接去改他的值
// 而是在新的房间赋值，把新房间的名字改为num，原来房间的名字恢复初始值

[图片]
[图片]

  （房间里面值变化了，或被删除了，只是断开了房间号和房内数据的联系，实际上数据还在，只是房间号变成默认值了（maybe里面有一个房间号变化的历史的链表结构记录着））
  （电脑的内存初始存：从头到尾存，发现到末尾了提示内存不足，然后删除东西，断开房间号和数据的联系，把房间号删除/恢复默认了，然后再存东西，把房间的数据覆盖了，然后才改房间号）


- 引用值
  - 原始值
    - Array
    - Object
    - Function
    - Date
    - RegExp
  - 存放位置：堆
    - 散列结构
    - 先新建一个房间到栈，然后拷贝目标值，如果目标值是引用值，则拷贝的是指向的地址
[图片]

  - 例子：
let arr = [1, 2];
let arr2 = arr;
arr = [1, 3];

// 这个时候，arr2的值有变化吗？没有，因为[1, 3]在堆那边又新开辟了一个房间
// arr指向的地址改变了，但arr2的地址没有改变
[图片]


运算
1. +
- 连接
- 加法
let a = 1 + 1 + 'a' + 1 + 1
// 输出2a11，前两个先算，然后遇到字符串变“2a”，再连接后面的

let a = 1 + 1 + 'a' + (1 + 2)
// 输出2a3，先算括号，再算前两个，再连接a

2. /
let a = 1 / 0
// 输出infinity

let a = -1 / 0
// 输出-infinity

let a = 0 / 0
// 输出NaN

3. 优先级
- =最弱，()最高
- ++的位置
  - a++：先执行本条语句，然后再++，这时a的值才改变
  - ++a：先++，a本身的值改变了，然后再执行本条语句
let a = 10;
let b = ++a - 1 + a++;
// b输出的是21——注意++a的时候a的值已经变成11了，所以第二个a++，这个时候的a是11
// a输出的是12
- += / %=
let a = 10;
a += 10 + 1;
// 输出21，拆开相当于 a = a + 10 + 1

a %= 2;
// 输出0，相当于a = a % 2

let a = 3
a %= 4
// 输出3，因为 0 * 4 + 3 = 3，相当于3是余数

a %= 0
// 输出0