# 浏览器
## 历史
- 真正显示图片的浏览器（迭代历史）
1. mosaic
2. Netscape navigator 网景
3. Mozilla Firefox

## 浏览器组成
- 两大部分
1. shell（贝壳，显示出来/用户能操作的部分）
2. 内核（看不到的部分）——>渲染进程？？里面的线程？？？
  1. 渲染引擎（从上到下，一层一层绘制，16.7ms更新一次）：语法规则和渲染
  2. js引擎
  3. 其他模块（异步）

- 其中js引擎的历史
  - ie6浏览器的js引擎：trident，把js引擎首次从内核独立出来
  - chrome浏览器的js引擎：webkit/blink（V8），把js代码直接转为机械码执行，速度快（原本应该是：js—>c++—>汇编码—>机械码—>执行）
  - firefox浏览器的js引擎：gecko，路径优化
  - Opera浏览器的js引擎：presto
  - safari浏览器的js引擎：webkit


# 语言
## 特征
1. 解释性语言
- 顶层语言翻译成机械码有不同的翻译的方法，分为：
  - 编译性：通篇翻译一下，然后一起执行。并非看一行执行一行
  - 解释性：翻译一行执行一行，然后在翻译第二行
- 优缺点：
  - 编译性：（c、c++）
    - 优点：快（系统类的底层）
    - 缺点：移植性不好（必须生成一个文件，因此不跨平台）

  - 解释性：（js、php）
    - 优点：跨平台（一行一行执行，不需要生成一个文件，不同平台都认识01）
    - 缺点：稍微慢

- 另外的：jvm（java虚拟机）
.java文件——（javac的指令）——（编译）——>.class文件——>jvm（解释执行）


2. 既面向对象又面向过程
- 面向对象：谁来干
- 面向过程：第一步第二步是什么



3. 单线程（js引擎）
（一个人一个时间只能干一件事，不能左手画圆右手画方）

- 分类
  - 同步：一件事做完再做下一件事。（但很快，且这一件事不一定是一件完整的事，看下面的#执行队列）
  - 异步：同时执行

- 执行队列
轮转时间片：类似吃饭

把任务切成一个个片段，随机性地排队，然后输入到js引擎里面


4. 语法规则
- 原生的：ECMAscript
- DOM
- BOM





## 编译
### 总体步骤
1. 语法分析（通篇扫描）
2. 预编译（解释为啥函数声明/变量-声明提升？？）
3. 解释执行（解释一行执行一行）


### 预编译
#### 问题引入
- 函数声明整体提升
```
test()
// 成功执行

function test() {
    console.log('ok')
}
```

- 变量-声明提升
```
console.log(a)
// 打印undefined
// 如果没有下面这一行，是会报错的，显示a is not defined

let a = '11'
```


#### 原则
- 变量没声明就赋值，此变量为全局对象（window）所有（也就是window是全局的域）

```
a = 10
// 等于window.a = 10


function test() {
    var a = b = 10
}
test()
// 首先把10赋值给b（但b是未声明的）
// 然后声明a
// 然后把b赋值给a
// 相当于从头到尾b都没有声明，也就是为全局变量

console.log(window.a)
// 值为undefined
console.log(window.b)
// 值为10
```


#### 干了什么，什么时候干
1. 局部预编译
（局部预编译发生在函数执行的前一刻）
```
function fn(a) {
    console.log(a);
    let a = 123;
    console.log(a);
    function a() {};
    console.log(a);
    let b = function() {};
    console.log(b);
    function d() {};
}
fn(1)
```

- 创建AO对象（Activation Object）（相当于执行上下文）
```
AO {

}
```

- 找形参（a）和变量声明（a和b），作为AO对象的key，值为undefined
```
AO {
    a: undefined,
    b: undefined,
}
```

- 形式参数的key的值为实际参数（实际参数和形式参数相统一）
```
AO {
    a: 1,
    b: undefined,
}
```

- 找函数声明（a和d），相应key值为函数体
```
AO {
    a: function a() {},
    b: undefined,
    d: function d() {},
}
```

！！！总结一下：
1. 形变
2. 形填充
3. 函填充（覆盖原有的实参数据，优先级最高）

- 最后结果
```
// 函数
function fn(a){
    console.log(a); //根据AO对象中的数据第一个打印的是：function a() {}
    
    // 变量声明+变量赋值（只提升变量声明，不提升变量赋值）
    var a = 123; // 执行到这时，由于变量赋值是不提升的，所以执行a = 123，a原本的函数值被123覆盖了
    // 注意！！上面这行代码换成let和const都说a已经被声明过了，var是正常的，因为var可以重复声明同名变量，且覆盖同名变量
    console.log(a); // 123
    
    // 函数声明
    function a(){}; // 这里被提升上去了，可以忽略
    console.log(a); // 123
    
    // 变量声明（函数表达式）
    var b = function(){};
    console.log(b); 
    // var b 作为变量声明已经提上去了，需要执行的是function() {} 赋值给b
    // AO对象中的数据被改了：function () {}
    
    // 函数声明
    function d(){};
}
//调用函数
fn(1);
```

2. 全局预编译
（全部预编译发生在页面加载完成时执行）
```
console.log(a)
// 返回function a() {}

let a = 123;
function a() {}
```

- 创建GO对象（Global Object）（相当于执行上下文）
```
GO {

}
```

- 找变量声明（a），作为AO对象的key，值为undefined
```
GO {
    a: undefined,
}
```

- 找函数声明（a和d），相应key值为函数体
```
GO {
    a: function a() {},
}
```


3. 当前局部上下文AO找不到目标值，才去上一级找（上一级的AO或者GO）。如果本身的AO有，就不需要去上一级找
- 简单版本
```
// 全局预编译写在最上面
GO = {
    global: undefined, // 后面执行第一行的时候变成100
    fn: function fn() {...},
}

global = 100;
function fn() {
    console.log(global);
    global = 200;
    console.log(global);
    var global = 300;
}

// 函数执行前预编译，所以写在这里
AO = {
    global: undefined, // 后面执行里面的global赋值的时候，global变为200，以及300
}

fn();
var global;
```


- 困难版本
```
GO = {
    test: function test() {...},
    a: undefined,
    c: 234, // 在执行到test函数内部的c = 234的时候，放到GO里面
}

function test() {
    console.log(b);
    if(a) {
        var b = 100;
    }
    console.log(b);
    c = 234;
    console.log(c);
}

var a;

AO = {
    b: undefined, 
    // 这里不管有没有if条件的限制，都会变量声明提升，直接忽略if条件
    // 但是在执行的时候，需要看if的条件是否满足，因为a此时为undefined，所以不满足条件，b后续不能被赋值
}

test();
a = 10;
console.log(c);
```

- 继续最后一个练习
```
// 第一个全局编译
function bar() {
    return foo;
    foo = 100;
    function foo() {}
    var foo = 11;
}
console.log(bar());
// 返回 function foo() {}


// 第二个全局编译
console.log(bar());
function bar() {
    foo = 10;
    function foo() {}
    var foo = 11;
    return foo;
}
// 返回 11
```




## 基础使用
### js的位置
- script标签
  - script标签的type还可以写成“text/tpl”，代码块无效，不执行，但里面可以存一下代码，后面可以取出来使用


### 规则
- 加分号：函数、for循环、if判断不用加；
- 错误：
  - 低级错误（语法解析错误）
    - 不对的符号
    - 在一行行解析之前，先通篇扫一遍看有没有低级错误，有则通篇都不会执行
  - 标准错误（逻辑错误）
    - 打印没有定义的变量
    - 执行到这行报错，然后后面的不再执行，上面的执行是正常的

（一个代码块的错误不会影响到另一个代码块的错误）



### 变量
- 变量声明与赋值：
  - 变量声明：

```
let a;

let a, b, c, d;
  - 变量赋值:
a = 100;
  - （先）变量声明，（后）赋值：
let a = 10,
    b = 20,
    c = 30;
  - （先）变量声明，（再）运算（从左到右），（最后）赋值（从右向左）
let a = b++ + 20;
```

- 变量命名：
_或$或字母为开头

_或$或字母或数字为内容



### 数据
- 数据类型
  - 原始值
    - Number
    - String
    - Boolean
    - Undefined
    - Null
  - 存放位置：栈（先进后出）
    - 栈内存之间的赋值是拷贝（比如用一个现有的值赋给一个新值）
    - 原始值是不可改变的！！！这句话如何理解？（数据进去房间之后就不能修改）

```
let num = 100;
num2 = num;
num = 200

// 最后的地方把num的值改变了，实际上已经存在房间里面的值是不可以被改变的
// 底层的实现不是去num的房间直接去改他的值
// 而是在新的房间赋值，把新房间的名字改为num，原来房间的名字恢复初始值
```

（房间里面值变化了，或被删除了，只是断开了房间号和房内数据的联系，实际上数据还在，只是房间号变成默认值了（maybe里面有一个房间号变化的历史的链表结构记录着））

（电脑的内存初始存：从头到尾存，发现到末尾了提示内存不足，然后删除东西，断开房间号和数据的联系，把房间号删除/恢复默认了，然后再存东西，把房间的数据覆盖了，然后才改房间号）


- 引用值
  - 原始值
    - Array
    - Object
    - Function
    - Date
    - RegExp
  - 存放位置：堆
    - 散列结构
    - 先新建一个房间到栈，然后拷贝目标值，如果目标值是引用值，则拷贝的是指向的地址


  - 例子：

```
let arr = [1, 2];
let arr2 = arr;
arr = [1, 3];

// 这个时候，arr2的值有变化吗？没有，因为[1, 3]在堆那边又新开辟了一个房间
// arr指向的地址改变了，但arr2的地址没有改变
```


运算
1. +
- 连接
- 加法

```
let a = 1 + 1 + 'a' + 1 + 1
// 输出2a11，前两个先算，然后遇到字符串变“2a”，再连接后面的

let a = 1 + 1 + 'a' + (1 + 2)
// 输出2a3，先算括号，再算前两个，再连接a

2. /
let a = 1 / 0
// 输出infinity

let a = -1 / 0
// 输出-infinity

let a = 0 / 0
// 输出NaN
```

3. 优先级
- =最弱，()最高
- ++的位置
  - a++：先执行本条语句，然后再++，这时a的值才改变
  - ++a：先++，a本身的值改变了，然后再执行本条语句

```
let a = 10;
let b = ++a - 1 + a++;
// b输出的是21——注意++a的时候a的值已经变成11了，所以第二个a++，这个时候的a是11
// a输出的是12
```

- += / %=

```
let a = 10;
a += 10 + 1;
// 输出21，拆开相当于 a = a + 10 + 1

a %= 2;
// 输出0，相当于a = a % 2

let a = 3
a %= 4
// 输出3，因为 0 * 4 + 3 = 3，相当于3是余数

a %= 0
// 输出0
```





### 比较
1. > 

```
let a = 'a' < 'b'
// 比较的是asc码
// 输出的是true

let a = '10' > '8'
// false
// 比顺序，首先1和8比，能比就比
```


- 比较字符串
  - 实际上比较的是他们对应的asc码
  - asc码本质上是七个01数，总共表示127个字符。
  - asc2码有8个01数，总共表示255个字符


2. ==和===
- 原始值转数字
- 引用值转字符串再转数字（转字符串之后其实相当于转为原始值了）

- ！（补充）：原始值转数字
  - 转为0
    - KFN
    - ""，false，null
  - 转为NaN
    - U（Y）
    - undefined、“包含非数字”


3. &&和||
- &&（找真）
  - 基础用法
    - 一表达式转布尔值为真？返回二表达式原始值（不转布尔）
    - 一表达式转布尔值为假？返回一表达式原始值（不转布尔）
    - 链式：一个为真，就往后看，一遇到假立刻返回假
  - 高级
    - （中断用法，短路语句）用作if语句：如果前面为真，就执行后面的语句

```
data && console.log(data)
```


- ||（找假）
  - 基础用法
    - 一表达式转布尔值为真？返回一表达式原始值（不转布尔）
    - 一表达式转布尔值为假？返回二表达式原始值（不转布尔）
  - 高级
    - （兼容/兜底用法）

```
let event = e || window.event
```


- ！（补充）：原始值转布尔值
  - 转为false
    - KUZAN
    - ""，undefined，0，NaN，null


- &
  - 与运算：相同为1，不同为0




### 类型转换

1. 判断类型
- typeof：UFO（undefined、function、object）

2. 显式转换
- 转为数字：Number()
  - 转为0
    - KFN
    - ""，false，null
  - 转为NaN
    - U（Y）
    - undefined、“包含非数字”

- 转为整数：parseInt(string, radix)
  - 转为NaN：其他非数字类型，非数字开头的字符串
  - 转为整数：数字或数字开头的字符串
```
let a = '100px'
parseInt(a)
// 输出100
```
  
  - 第二个参数：【转10】把当前第一个参数当做：第二个参数表示的进制数，转化第一个参数为10进制
    - 范围是2-36
```
parseInt('b', 16)
// 输出的是11
```

- 转为小数：parseFloat(string)
  - 转为NaN：其他非数字类型，非数字开头的字符串
  - 转为整数：数字或数字开头的字符串



- 转为字符串：
  - String(xxx)或者+ ''
    - 什么东西都会转化成字符串
  - xxx.toString(radix)
    - undefined和null没有这个方法，用不了
    - 第二个参数：【10转】把前面的数字当成是10进制，然后转化成第二个参数定义的进制（注意：只有在前面的数据是数字的时候才ok）
```
'10'.toString(8)
// 输出12
```

- 转为布尔值
  - 转为false
    - KUZAN
    - ""，undefined，0，NaN，null



3. 隐式转换
- isNaN()
  - 内部先Number()，然后再把结果和NaN相比较

- 非加法运算：内部先Number()
  - ++/--或者+/-（正负）
  - *、-、/、%
- 加法运算（+）：有string就用toString方法

- 比较
  - < 或 > ：先Number()，如果两个都是字母字符串，比较asc码
  - && 或 || 或 ! ：转布尔值
  - == 或 === ：
    - 原始值转数字，Number()
    - 引用值转字符串再转数字（转字符串之后其实相当于转为原始值了）

- 特殊
  - undefined == null ——>true
  - NaN === NaN ——> false
  - typeof xxx ——>返回的值是字符串类型
```
typeof typeof undefined
// 返回string
// 相当于 typeof  'undefined'
```






### for/while
- for循环：底层执行顺序
```
for (let i = 0; i < 10; i++)
```
1. 【左】初始值的定义（只执行一遍）
2. 【中】判断limit条件
3. 【下】执行语句
4. 【右】执行下一步操作
5. step2-4循环执行！！！


- while循环：for循环不写分号前后两个就是while循环
（打印10次）

- do..while：不管while条件，首先都要执行do里面的语句


